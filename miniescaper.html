<meta charset=utf-8>
<input id=p size=30> Plain text<br><br>
<input id=a readonly size=30> \uXXXX (JS)<br>
<input id=b readonly size=30> &#DDDD; (HTML)<br>
<input id=c readonly size=30> &#xXXXX; (HTML)<br>
<input id=d readonly size=30> \xXX (UTF-8)<br>
<input id=e readonly size=30> \OOO (UTF-8)<br>
<input id=f readonly size=30> Base64 (UTF-8)<br>
<input id=g readonly size=30> URL<br>
<input id=h readonly size=30> selector (CSS)<br>
<input id=i readonly size=30> querySelector (JS)
<script>

// Convert plain text in other formats for the web
// todo: finish astral unicode support (xXX, OOO, base64) -- ðŒ†
// todo: avoid to escape EVERYTHING in css/js selectors.

oninput=function(){
  
  // Initialize converted strings
  A=B=C=D=E=F=G=H=I='';
  
  // Initialize hex (x), minihex (m), surrogate-free minihex (sfm), surrogate-free integer (sfn), integer (n) and octal (o) values for each char
  x=[];m=[];n=[];sfm=[];sfn=[];o=[];
  
  // Loop on chars
  for(z in v=p.value){
    
    // Update x, m, n, o, s, sfn, sfm
    x[z]=(("000"+(m[z]=(n[z]=v.charCodeAt(z)).toString(16))).slice(-4));
    o[z]=n[z].toString(8);
    
    // Gather surrogate pairs into unique code points
    if(n[z]>=0xD800&&n[z]<=0xDBFF){
      tmp=(n[z]-0xD800)*0x400+v.charCodeAt(z+1)-0xDC00+0x10000;
      sfn.push(tmp);
      sfm.push(tmp.toString(16));
    }
    else if((n[z]&0xFC00)!=0xDC00){
      sfn.push(n[z]);
      sfm.push(m[z]);
    }
    
    // Update inputs values
    A+="\\u"+x[z];
    if(sfn[z])B+="&#"+sfn[z]+";";
    if(sfm[z])C+="&#x"+sfm[z]+";";
    D+="\\x"+m[z];
    E+="\\"+o[z];
    // F todo
    // G not todo
    H+="#\\"+m[z]+" ";
    I+="#\\\\"+m[z]+" ";
  }
  
  // Update inputs
  a.value=A;
  b.value=B;
  c.value=C;
  d.value=D;
  e.value=E;
  try{f.value=btoa(v)}catch(e){};
  g.value=encodeURIComponent(v);
  h.value=H + "{ }";
  i.value='"' + I + '"';
}
</script>